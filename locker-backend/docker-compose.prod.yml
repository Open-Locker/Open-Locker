x-laravel-env-prod: &laravel_env_prod
  PUID: "1000"
  PGID: "1000"
  WWWUSER: "1000"
  APP_ENV: production
  QUEUE_CONNECTION: redis
  BROADCAST_CONNECTION: reverb
  DB_HOST: db
  REDIS_HOST: redis
  MQTT_BROKER_HOST: mqtt
  REVERB_APP_ID: "${REVERB_APP_ID}"
  REVERB_APP_KEY: "${REVERB_APP_KEY}"
  REVERB_APP_SECRET: "${REVERB_APP_SECRET}"
  # Internal Reverb endpoint for Laravel app/worker containers.
  REVERB_HOST: reverb
  REVERB_PORT: 8080
  REVERB_SCHEME: http
  REVERB_SERVER_HOST: 0.0.0.0
  REVERB_SERVER_PORT: 8080
  # Browser-facing Echo settings.
  VITE_REVERB_APP_KEY: "${REVERB_APP_KEY}"
  VITE_REVERB_HOST: "${VITE_REVERB_HOST}"
  VITE_REVERB_PORT: "${VITE_REVERB_PORT}"
  VITE_REVERB_SCHEME: https
  # Keep Laravel app version aligned with the deployed image tag
  APP_VERSION: "${BACKEND_IMAGE_TAG:-latest}"

x-laravel-service-prod: &laravel_service_prod
  image: ghcr.io/open-locker/locker-backend:${BACKEND_IMAGE_TAG:-latest}
  volumes:
    # Mount storage for persistent file uploads
    - "locker-storage:/var/www/html/storage/app/public"
    # Persist logs if needed
    # - "locker-logs:/var/www/html/storage/logs"

x-app-depends-on-prod: &app_depends_on_prod
  db:
    condition: service_healthy
  redis:
    condition: service_healthy

x-worker-depends-on-prod: &worker_depends_on_prod
  app:
    condition: service_healthy
  db:
    condition: service_healthy
  redis:
    condition: service_healthy
  mqtt:
    condition: service_started

services:
  app:
    <<: *laravel_service_prod
    extra_hosts:
      - "host.docker.internal:host-gateway"
    # ports:
    # Expose the app port via reverse proxy
    # - "${APP_PORT:-80}:8080"
    environment:
      <<: *laravel_env_prod
      AUTORUN_ENABLED: "true"
      AUTORUN_LARAVEL_MIGRATION_ISOLATION: "true"
      LARAVEL_SAIL: 0
      APP_DEBUG: false
      # Ensure unique MQTT client ids per container to avoid session kicks
      MQTT_PUBLISHER_CLIENT_ID: "laravel_backend_publisher_app"
      PHP_OPCACHE_ENABLE: 1
    depends_on:
      <<: *app_depends_on_prod
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/up"]
      interval: 5s
      timeout: 5s
      retries: 5

  queue-worker:
    <<: *laravel_service_prod
    restart: unless-stopped
    stop_signal: SIGTERM
    environment:
      <<: *laravel_env_prod
      AUTORUN_ENABLED: "false"
      MQTT_PUBLISHER_CLIENT_ID: "laravel_backend_publisher_queue_worker"
    command: "php artisan queue:work --queue=default --tries=3 --timeout=90"
    depends_on:
      <<: *worker_depends_on_prod
    healthcheck:
      test: ["CMD", "healthcheck-queue"]
      start_period: 10s
      interval: 30s
      timeout: 10s
      retries: 3

  event-worker:
    <<: *laravel_service_prod
    restart: unless-stopped
    stop_signal: SIGTERM
    environment:
      <<: *laravel_env_prod
      AUTORUN_ENABLED: "false"
      MQTT_PUBLISHER_CLIENT_ID: "laravel_backend_publisher_event_worker"
    command: "php artisan queue:work --queue=events --tries=3 --timeout=90"
    depends_on:
      <<: *worker_depends_on_prod
    healthcheck:
      test: ["CMD-SHELL", "php artisan queue:monitor events || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

  mqtt-listener:
    <<: *laravel_service_prod
    restart: unless-stopped
    stop_signal: SIGTERM
    environment:
      <<: *laravel_env_prod
      AUTORUN_ENABLED: "false"
      # mqtt-listener uses both listener + publisher connections
      MQTT_LISTENER_CLIENT_ID: "laravel_backend_listener_mqtt_listener"
      MQTT_PUBLISHER_CLIENT_ID: "laravel_backend_publisher_mqtt_listener"
    command: "php artisan mqtt:listen"
    depends_on:
      <<: *worker_depends_on_prod

  scheduler:
    <<: *laravel_service_prod
    restart: unless-stopped
    stop_signal: SIGTERM
    environment:
      <<: *laravel_env_prod
      AUTORUN_ENABLED: "false"
    command: "php artisan schedule:work"
    depends_on:
      <<: *worker_depends_on_prod
    healthcheck:
      test: ["CMD", "healthcheck-schedule"]
      start_period: 10s
      interval: 30s
      timeout: 10s
      retries: 3

  reverb:
    <<: *laravel_service_prod
    restart: unless-stopped
    stop_signal: SIGTERM
    environment:
      <<: *laravel_env_prod
      AUTORUN_ENABLED: "false"
    command: "php artisan reverb:start --host=0.0.0.0 --port=8080"
    depends_on:
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "healthcheck-reverb"]
      start_period: 10s
      interval: 30s
      timeout: 10s
      retries: 3

  mqtt:
    image: iegomez/mosquitto-go-auth:latest
    restart: unless-stopped
    ports:
      - "1883:1883"
    volumes:
      - "./mosquitto/mosquitto.conf:/etc/mosquitto/mosquitto.conf:ro"
      - "locker-mqtt-data:/mosquitto/data"
    environment:
      TZ: UTC
    depends_on:
      app:
        condition: service_healthy

  redis:
    image: "redis:alpine"
    volumes:
      - "locker-redis:/data"
    healthcheck:
      test:
        - CMD
        - redis-cli
        - ping
      retries: 3
      timeout: 5s

  db:
    image: "postgres:17"
    environment:
      PGPASSWORD: "${DB_PASSWORD}"
      POSTGRES_DB: "${DB_DATABASE}"
      POSTGRES_USER: "${DB_USERNAME}"
      POSTGRES_PASSWORD: "${DB_PASSWORD}"
    volumes:
      - "locker-pgsql:/var/lib/postgresql/data"
    healthcheck:
      test:
        - CMD
        - pg_isready
        - "-q"
        - "-d"
        - "${DB_DATABASE}"
        - "-U"
        - "${DB_USERNAME}"
      retries: 3
      timeout: 5s
volumes:
  locker-redis:
    driver: local
  locker-pgsql:
    driver: local
  locker-storage:
    driver: local
  locker-mqtt-data:
    driver: local
